{
  "Data integrity": "Accuracy, consistency and reliability of data throughout its entire lifecycle.",
  "Data validation": "The process of assessing whether data is of the right format or within a specified range (It does not guarantee that data is accurate).",
  "Data verification": "The process of confirming that the data entered to the system was intended.",
  "Data validation checks": "Presence check, format check, length check, range check.",
  "Presence check": "Check that an entry field is not left blank.",
  "Format check": "Check that the data is in a specified format or pattern.",
  "Length check": "Check that a specific number of characters or digits has been entered.",
  "Range check": "Check that the data is between a lower and an upper limit.",
  "Check digit": "A digit that helps confirm that the entry is correct.",
  "Data verification methods": "Visual check, double entry verification and cross-field verification.",
  "Visual check": "Compare the data entered into the system is the same as the original data (which could be a digital document or paper records).",
  "Double entry verification": "It requires a user to input the same information twice, and the values are compared.",
  "Cross-field verification": "It validates across different fields, e.g. checking if age entered is consistent with birthdate.",
  "Checksum algorithm": "A checksum algorithm is a method used to verify the integrity of data by generating a small, fixed-size value (the checksum) from a larger set of data. This checksum value is calculated and attached to the data during transmission or storage. When the data is later retrieved or received, the checksum is recalculated and compared to the original checksum to detect any errors or corruption that might have occurred.",
  "Hash function": "A hash function is a mathematical algorithm that takes an input (or 'message') and returns a fixed-size string of bytes, which is typically a hash code. The output, often called the hash value or hash digest, is usually a representation of the data in a way that is unique or nearly unique. Hash functions are commonly used in many areas of computer science and cryptography.",
  "Characteristics hash function": "Deterministic: The same input will always produce the same hash value. Fixed Output Size: Regardless of the input size, the output is always of a fixed length (e.g., 256 bits for SHA-256). Efficient Computation: The hash function should be fast to compute for any given input. Pre-image Resistance: Given a hash value, it should be computationally difficult to find the original input that produced it. Small Changes Produce Different Hashes: A small change in the input should produce a significantly different hash, often called the avalanche effect. Collision Resistance: It should be hard to find two different inputs that produce the same hash value (i.e., no two inputs should 'collide' at the same hash).",
  "Uses hash functions": "Data Integrity: Hash functions are used to verify that data has not been altered. For example, checksums or file integrity checks. Cryptography: Cryptographic hash functions (e.g., SHA-256, MD5) are crucial for encryption and digital signatures. Hash Tables: In data structures, hash functions are used to map data to fixed locations for quick access (e.g., in hash maps or dictionaries). Password Storage: Hash functions are often used to store hashed versions of passwords in databases for security purposes.",
  "One-bit parity check": "A one-bit parity check is a simple error detection mechanism that adds a single bit (known as a parity bit) to a data sequence to ensure that the total number of 1s in the sequence meets a specific criterion. This method helps detect single-bit errors in data transmission.",
  "Types parity checks": "Even parity: The parity bit is set such that the total number of 1s in the data, including the parity bit, is even. For example, if the data sequence is 1010 (which has two 1s), the parity bit would be 0 to maintain an even number of 1s (10100). Odd parity: The parity bit is set so that the total number of 1s, including the parity bit, is odd. For example, if the data sequence is 1010 (two 1s), the parity bit would be 1 to make the total number of 1s odd (10101). The receiver can then check the parity to determine if an error occurred during transmission. However, a one-bit parity check can only detect errors where a single bit is flipped and cannot correct the error or detect errors that affect an even number of bits.",
  "Syntax error": "Syntax errors occur when the code violates the rules of the programming language.",
  "Runtime error": "Runtime errors occur during the execution of the program. These errors can be caused by factors such as division by zero, accessing an index out of range, or using an undefined variable.",
  "Logic error": "Logic errors occur when the code is syntatically correct but it does not produce the intended results due to a mistake in the logic or algorithm.",
  "Types test cases": "Normal, Extreme and Abnormal",
  "Normal test case": "Values we expect to enter.",
  "Extreme test case": "Values at the limits of expectations we should be accepted.",
  "Abnormal test case": "Data that falls outside what is acceptable and should be rejected.",
  "Linear search": "A linear search is the simplest approach to search for an element in an array. It examines each element sequentially from the beginning until it finds a match. Implementation:\n\n def lin_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n",
  "Searching algorithms": "Linear search, Binary search, Hash table search and implementing binary search tree.",
  "Binary search": "Binary search looks for a target item by comparing the middle element of the array. If a match occurs, the index is returned. If the middle element is greater, then search in the sub-array to the left of the middle element. Otherwise, search in the sub-array to the right. For this algorithm to work, the data collection needs to be in sorted form. Implementation:\n\ndef bin_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n    while left <= right:  (#check if search range is valid)\n        mid = (left + right) // 2\n        mid_element = arr[mid]\n        if target == mid_element:\n            return mid  (# target found)\n        elif target < mid_element:  (# target in left half)\n            right = mid - 1  # discard right half\n        else:  (# target in right half)\n            left = mid + 1  (# discard left half)\n    return -1  (# target not found)\n",
  "Sorting algorithms": "Insertion sort, bubble sort, quick sort and merge sort.",
  "Insertion sort": "Insertion sort is a simple and efficient sorting algorithm. It builds the sorted array one element at a time by repeatedly taking the next element and inserting it into its correct position in the already sorted portion of the array. The code goes like this:\n\n def insertion_sort(arr):\n    # loop from the second element until the last element\n    for i in range(1, len(arr)):\n        key_element = arr[i]  (# element to be inserted)\n        j = i - 1  (# initialise variable to be used to identify the correct position)\n        while j >= 0 and arr[j] > key_element:\n            arr[j + 1] = arr[j]  (# shift the element to the right)\n            j -= 1  (# continue checking next element on the left)\n        (# once done shifting elements, insert key element in its correct position)\n        arr[j + 1] = key_element\n",
  "Characteristics Insertion sort": "Efficiency and simplicity\n- It is one of the simplest algorithms with a simple implementation.\n- It performs reasonably well for small datasets.\nIn-place sorting\n- It sorts the array by modifying it directly. Therefore, it does not require additional memory allocation proportional to the input array size.\nStable sorting\n- It preserves the relative order of equal elements in the sorted array.\nAdaptive\n- It performs well on nearly sorted or partially sorted arrays. Therefore it is useful in situations where elements are continuously added to a sorted list and need to be maintained in a sorted order.",  
  "Bubble sort non-optimised": "Bubble sort is another simple and intuitive algorithm. It repeatedly steps through the array, comparing adjacent elements and swapping them if they are in the wrong order. Implementation:\n\n def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):  (# requires (n - 1) passes)\n        for j in range(n - i - 1):  (# last i elements are already in place)\n            if arr[j] > arr[j + 1]:  (# swap if the elements are not in order)\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n",
  "Bubble sort": "Always give this in Cambridge exams.This is the optimsed code. Implementation:\n\n def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):  (# requires max (n - 1) passes)\n        swapped = False  (# flag to check if any swaps occur)\n        for j in range(n - i - 1):  (# last i elements are already in place)\n            if arr[j] > arr[j + 1]:  # swap if the elements are not in order\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  (# array is already sorted)\n            break\n",
  "Characteristics bubble sort": "Simplicity\n- Bubble sort is straightforward to implement.\nIn-place sorting\n- It sorts the array by modifying it directly. No additional memory allocation that is proportional to the input array size is needed.\nStable sorting\n- Preserves the relative order of equal elements in the sorted array.\nBubble sort is inefficient for large arrays.\n- Similar to insertion sort, the worst-case scenario would be when the input array is in reverse order. Maximum number of comparisons and swaps are required to sort the array.\n- For a nearly sorted array, insertion sort is generally more efficient compared to bubble sort. For such a case, insertion sort’s approach of inserting one element at a time in its correct position is effective and requires fewer comparisons and swaps.",
  "Database": "A database is an organized collection of structured information, or data, typically stored electronically in a computer system.",
  "Quicksort": "Quicksort is a highly efficient and widely-used sorting algorithm based on the divide-and-conquer paradigm. It divides the array into sub-arrays based on a pivot element and recursively sorts these sub-arrays. Implementation:\n\n def quicksort(arr):\n    if len(arr) <= 1:  (# base case)\n        return arr\n    (# Here, we choose pivot as the middle element, but you can choose others.)\n    pivot = arr[len(arr) // 2]\n    left = []\n    middle = []\n    right = []\n    for element in arr:\n        if element < pivot:\n            left.append(element)\n        elif element == pivot:\n            middle.append(element)\n        else:\n            right.append(element)\n    return quicksort(left) + middle + quicksort(right)  (# combine)\n",
  "Merge sort": "Merge sort is also an efficient algorithm based on the divide-and-conquer paradigm. Implementation:\n\n def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr  (# base case)\n    (# Divide array into 2 halves)\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    (# Recursively sort each half)\n    left = merge_sort(left)\n    right = merge_sort(right)\n    (# Merge the sorted halves)\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0  (# indices for left and right halves)\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:  (# compare elements from left and right halves)\n            result.append(left[i])  (# append the smaller element)\n            i += 1  (# move to the next element in left half)\n        else:\n            result.append(right[j])\n            j += 1\n    (# Add any remaining elements)\n    result = result + left[i:] + right[j:]\n    return result\n",
  "time complexity of merge sort": " O(nlogn)",
  "time complexity of bubble sort": " O(n^2)",
  "time complexity of quicksort": "O(n^2)",
  "time complexity of insertion sort": "O(n^2)",
  "time complexity of binary search": "O(logn)",
  "time complexity of linear searcgh": "O(n)",
  "Entity-Relationship diagram": "An Entity-Relationship (E-R) diagram is a high-level visual representation of the data model that defines the structure and relationships within a database.",
  "E-R diagram": "An Entity-Relationship (E-R) diagram is a high-level visual representation of the data model that defines the structure and relationships within a database."
}

